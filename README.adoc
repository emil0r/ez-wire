= ez-wire

Wire things together, in Clojurescript. Meant to be used together with reagent and re-frame.

* form

== form

form handles generic rendering, form validation, i18n and ties in with re-frame.

Define a form, give it which elements to render the input field with, and then render it as a table, paragraphs, list, template or define it yourself to the t. Table, paragraph, list and template are all supported as wizards.

Form validation and i18n are supported via protocols and have default implementations.

[source,clojure]
----
(myns
  (:require [clojure.spec.alpha :as spec]
            [clojure.string :as str]
            [ez-wire.form :as form]
            [ez-wire.form.helpers :refer [valid?]]
            [myns.fomantic.elements :as e] ; <-- elements from fomantic UI. e/input is a standard input field from fomantic UI
            [reagent.core :as r]
            [re-frame.core :as rf])
  (:require-macros [ez-wire.form.macros :refer [defform]]
                   [ez-wire.form.validation :refer [defvalidation]]))

;; we adapt our input to ez-wire.form's internal data model
(defn text-adapter [{:keys [element] :as field}]
  (let [f (r/adapt-react-class element)] ; <-- adapt to reagent
    ;; IMPORTANT NOTE: model is a cursor into a RAtom that is created internally whenever a defform is called
    (fn [{:keys [value model] :as data}] ; <-- this is the data that is sent in as default to all elements form an ez-wire form
                                         ; it correspends with the data that is defined in defform
      [f (merge {:defaultValue value ; <-- set default value. this is so that we don't get a jumping cursor
                 :on-change #(reset! model (-> % .-target .-value))} ; <-- how we update
                (select-keys data [:id :placeholder]))])))

;; an adapter for integers
(defn integer-adapter [{:keys [element] :as field}]
  (let [f (r/adapt-react-class element)]
    (fn [{:keys [model value] :as data}]
      [f (merge {:defaultValue (str value)
                 :on-change #(let [value (-> % .-target .-value)
                                   int-value (js/parseInt value)]
                               (if-not (js/isNaN int-value)
                                 (reset! model int-value)
                                 (reset! model value)))}
                (select-keys data [:id :placeholder]))])))


;; validation can be anything and is supported via protocols.
;; in this case the default implementation uses spec (version 1) and a error message (fn or string/keyword)
;; i18n is also supported via protocols and supports nil, strings and keywords by default. extend to any i18n library you wish
(defvalidation ::int
  (spec/or :int int? :blank str/blank?)
  (fn [{:keys [value]}]
    [:div "current value is " [:strong "'" value "'"] " and it needs to be an integer"]))
(defvalidation ::percent
  #(and (>= % 0) (<= % 100))
  (fn [{:keys [value]}]
    [:div "current value is " [:strong "'" value "'"] " and it needs to be between 0 and 100"]))
(defvalidation ::long-string
  (spec/and string?
            #(> (count %) 2))
  "Need to be a string and more than two characters")  

(defform testform ; <-- creates a function by name of testform
  {} ; <-- options
  [{:element e/input ; <-- which element do we render with
    :adapter text-adapter ; <-- any adapter, if needed
    :placeholder "foobar" ; <-- ends up being sent in
    :validation [::long-string] ; <-- our validations we wish to perform
    :value "test" ; <-- default value
    :name :test1 ; <-- the name of our field
    :label "My test input" ; <-- label input
    :help "My help text for test input" ; <-- help text
    :text "My info text"} ; <-- info text
    {:element e/input
    :adapter integer-adapter
    :placeholder "Numbers"
    :validation [::int ::percent] ; <-- we can have multiple validations
    :value ""
    :name :test2}
   {:element e/input
    :adapter text-adapter
    :placeholder "Third"
    :value ""
    :wiring [:tr [:td "bar"] [:td :$field]] ; <-- override the default layout
    :name :test3}])
    
    
(defn home-page []
  (let [data {:test1 "my test data"
              :test2 "Faulty data"}
        form (testform ; <-- our form called as a function
              {} ; <-- options that can be used to override the default options defined in defform
              data) ; <-- our data to be passed in to our form
        ;; subscription to validity of the form. if valid it returns the
        ;; data, if invalid it returns :ez-wire.form/invalid
        valid-form (rf/subscribe [::form/on-valid (:id form)])]
        (fn []
          [:div
            [:h2 "My form (as a table)"]
            [form/as-table {} form]
            [:button {:on-click #(js/alert @valid-form)} "Alert data"]
            (when (valid? valid-form)
              [:div "Form is valid")])))

----

External errors can also be added.

[source,clojure]
----
(require '[ez-wire.form.helpers :as helpers])

(let [myform (testform {})]
 ;; this will add an external error message
 ;; the last parameter valid? controls whether the error message will pass the validity control
 ;; set to true to always pass
 ;; set to false to force a manual removal
 (helpers/add-external-error form :my-field :my-id-of-the-error-message "My actual error message" true) ;; [form field-name id error-message valid?]
 (helpers/remove-external-error form :my-field :my-id-of-the-error-message))

----


== License

Copyright Â© 2020 Emil Bengtsson

___
Coram Deo
